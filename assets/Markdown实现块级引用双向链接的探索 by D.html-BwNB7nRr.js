import{_ as r,c as o,a,b as i,e,d,w as l,r as p,o as k}from"./app-CJY8nRa-.js";const s={};function m(M,t){const n=p("RouteLink");return k(),o("div",null,[t[6]||(t[6]=a("p",null,[e("202107121945"),a("br"),e(" 因为现在群里不太关注此话题，并且"),a("a",{class:"route-link nolebase-route-link-invalid",href:"#",target:"_target"},"思源笔记"),e("似乎也放弃了此方案，所以移动到其他文件夹。")],-1)),t[7]||(t[7]=a("hr",null,null,-1)),a("p",null,[t[1]||(t[1]=e("Markdown 实现块级引用双向链接的探索",-1)),t[2]||(t[2]=a("br",null,null,-1)),t[3]||(t[3]=e(" 作者",-1)),d(n,{to:"/07 信息源与贡献者/D.html"},{default:l(()=>[...t[0]||(t[0]=[e("D",-1)])]),_:1}),t[4]||(t[4]=e("，",-1)),t[5]||(t[5]=a("a",{href:"https://hacpai.com/article/1597226949061?tdsourcetag=s_pctim_aiomsg",target:"_blank",rel:"noopener noreferrer"},"原文链接",-1))]),t[8]||(t[8]=i('<h2 id="双向链接" tabindex="-1">双向链接</h2><p>从技术上来说，“双向链接” 存在已久，并且应用在了很多系统中，比如维基中词条引用，博客中的 PingBack。它表达了有向的关联关系，让用户可以更好地获取到相关信息。</p><p>从 Roam Research 重新定义大纲式笔记开始，知识管理领域里很多系统开始加入双链特性。从方便用户理解和使用上，内容大致可以被分为为：</p><ul><li>页面（Page）：通过标题或者 URL 标识，可以包含子页面和内容块</li><li>内容块（Block）：通过 id 标识，可以包含更多内容块</li></ul><p>每个厂商对页面和内容块的实现都是不一样的，但从基本逻辑上看，块可以嵌套块，块组合构成页面，整体是树形结构。块通过唯一的 id 进行标识。通过 id 可以方便地存储和表达两个块之间的关系，从而进一步生成关系图图。</p><h2 id="markdown-中的块" tabindex="-1">Markdown 中的块</h2><p>和厂商自定义的格式不同，Markdown 是开放的公开格式，最重要的是 Markdown 是基于文本的，没有显示的格式（Schema）约束，这是 Markdown 受欢迎的原因之一，因为这极大的方便了用户读写，但同时这也给制定 Markdown 规范和实现解析器增加了很大难度。</p><p>Markdown 发展到现在，基本所有解析器都开始实现或者已经实现了 CommonMark/GFM 规范。在规范中，Markdown 文本内容被划分为块级元素和行级元素，块级元素又分为叶子块和容器块。叶子块只能包含行级元素，容器块可以包含块级元素。从基本逻辑上看，Markdown 是通过块嵌套来组成文档，整体也是树形结构。</p><h2 id="markdown-块链之难" tabindex="-1">Markdown 块链之难</h2><p>对于 RR 类系统来说，内容块在设计之初就已经是结构化的了。只要能在系统里输入的内容都会存在于一个定义好的块里，并且这个块可以通过 id 检索到。</p><p>但是对于 Markdown 来说，情况就不一样了，因为规范中并没有定义 id 元素。从用户角度上看，也不太可能让所有人都在文本中通过某种语法来定义块 id，这样即复杂也不可靠，并且违背了 Markdown 简单文本（Plain Text）的本意，更重要的是失去了 Markdown 的互操作性。</p><p>综上，Markdown 块链的难点在于找到标识 Markdown 块的方法。</p><h2 id="可能的解决方案" tabindex="-1">可能的解决方案</h2><p>这里需要稍微介绍一下 Markdown 处理的步骤（细节请浏览<a href="https://hacpai.com/article/1587637426085" target="_blank" rel="noopener noreferrer">这里</a>）：</p><ol><li>读取 Markdown 文本</li><li>解析文本生成 Markdown 抽象语法树（Markdown AST）</li><li>通过遍历 AST 输出渲染结果</li></ol><p>前面提到过，在文本中标识 id 基本不可行，所以步骤 1 我们就不讨论了。在步骤 2 中生成的块节点上加入 id 是没问题的，这样步骤 3 渲染后也可以将 id 返回到用户界面中，以便后续做块关联时使用。</p><p>这样就解决了？当然没那么简单，因为这里忽略了一个很重要的问题，用户编辑输入是持续发生的，本次渲染输出会作为下次的解析输入，而解析输入是 Markdown 文本，是不会有 id 的。</p><h3 id="自旋方案" tabindex="-1">自旋方案</h3><p>id 需要在整个使用过程中带着走，才能 “自圆其说”。由此，我们得出以下处理步骤：</p><ol><li>读取 DOM，记录块 id</li><li>DOM 转 Markdown</li><li>Markdown 转 AST</li><li>AST 渲染为新 DOM</li><li>将块 id 合并回新 DOM 返回</li></ol><p>我把这个方案叫做” 自旋 “（Spin），即老 DOM -&gt; 新 DOM。自旋相关的细节问题我们暂时略过，回到块链上，只要合并算法可靠，我们就能解决 id 在用户编辑时不丢失的问题。</p><p>到这里，我们已经解决一半的问题了，即编辑时可以保证不丢失块标识，新生成的块也有标识。另一半问题是持久化，即如何从磁盘上还原起始状态的 DOM。</p><h3 id="持久化" tabindex="-1">持久化</h3><p>饶了一圈，还是回到了 Markdown 文本不能存 id 的问题上，不换存储格式应该无解，换了格式又觉得丢失灵魂。作为设计者，终究会有抉择的时刻。这个问题上，我选择的是换格式，通过 JSON 进行持久化，但需要提供完善的 Markdown 导出支持。</p><p>实现上是将 Markdown AST 使用 JSON 渲染器渲染，输出为 JSON 文本存盘，在需要时读取 JSON 文本反序列化为 AST 。JSON 中必须带有 AST 节点的 id 和一些其他必备属性，这样反序列后才能还原完整的 AST。</p><h3 id="简化问题" tabindex="-1">简化问题</h3><p>完整实现所有 Markdown 块级元素的双链比较困难，但是仅实现那些可以自描述的块级元素（比如标题元素）是毫无问题的，因为标题本身的内容可以当做块 id，这样既能保持 Markdown 的文本形态，又不用添加新的语法。这方面<a href="https://link.hacpai.com/forward?goto=https%3A%2F%2Fobsidian.md" target="_blank" rel="noopener noreferrer">黑曜石</a>（Obsidian）已经给我们做了很好的示范。</p><h2 id="markdown-块链的意义" tabindex="-1">Markdown 块链的意义</h2><p>实现 Markdown 块链方案的探索暂时告一阶段。回过头来，我们需要重新审视块链存在的意义，也许较有说服了的点是：在较细粒度上将信息进行连接，同时又不破坏信息的上下文。</p><p>我有点描述不出来块链的使用场景，我觉得这很难想象，描述它就像是在解构自己的思维。工具方法的价值是由使用者确立的，根据使用者的反馈做出改进，这件事情才会慢慢变得具有意义。</p><p>最后，如果你想体验支持 Markdown 块级引用双向链接，欢迎关注<a href="https://link.hacpai.com/forward?goto=https%3A%2F%2Fliandi.b3log.org" target="_blank" rel="noopener noreferrer">链滴笔记</a>。</p>',31))])}const w=r(s,[["render",m]]),c=JSON.parse('{"path":"/09%20%E7%A2%8E%E8%AE%B0/Markdown%E5%AE%9E%E7%8E%B0%E5%9D%97%E7%BA%A7%E5%BC%95%E7%94%A8%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5%E7%9A%84%E6%8E%A2%E7%B4%A2%20by%20D.html","title":"Markdown实现块级引用双向链接的探索 by D","lang":"zh-CN","frontmatter":{"description":"202107121945 因为现在群里不太关注此话题，并且思源笔记似乎也放弃了此方案，所以移动到其他文件夹。 Markdown 实现块级引用双向链接的探索 作者，原文链接 双向链接 从技术上来说，“双向链接” 存在已久，并且应用在了很多系统中，比如维基中词条引用，博客中的 PingBack。它表达了有向的关联关系，让用户可以更好地获取到相关信息。 从 ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-29T11:15:30.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://LincDocs.github.io/obsidian-chinese-help/09%20%E7%A2%8E%E8%AE%B0/Markdown%E5%AE%9E%E7%8E%B0%E5%9D%97%E7%BA%A7%E5%BC%95%E7%94%A8%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5%E7%9A%84%E6%8E%A2%E7%B4%A2%20by%20D.html"}],["meta",{"property":"og:site_name","content":"obsidian-chinese-help"}],["meta",{"property":"og:description","content":"202107121945 因为现在群里不太关注此话题，并且思源笔记似乎也放弃了此方案，所以移动到其他文件夹。 Markdown 实现块级引用双向链接的探索 作者，原文链接 双向链接 从技术上来说，“双向链接” 存在已久，并且应用在了很多系统中，比如维基中词条引用，博客中的 PingBack。它表达了有向的关联关系，让用户可以更好地获取到相关信息。 从 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-29T11:15:30.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-29T11:15:30.000Z"}]]},"git":{"createdTime":1761736530000,"updatedTime":1761736530000,"contributors":[{"name":"Linc","username":"Linc","email":"762699299@qq.com","commits":1,"url":"https://github.com/Linc"}]},"readingTime":{"minutes":5.29,"words":1587},"filePathRelative":"09 碎记/Markdown实现块级引用双向链接的探索 by D.md","excerpt":"<p>202107121945<br>\\n因为现在群里不太关注此话题，并且<a class=\\"route-link nolebase-route-link-invalid\\" href=\\"#\\" target=\\"_target\\">思源笔记</a>似乎也放弃了此方案，所以移动到其他文件夹。</p>\\n<hr>\\n<p>Markdown 实现块级引用双向链接的探索<br>\\n作者<a href=\\"/obsidian-chinese-help/07 信息源与贡献者/D.html\\" target=\\"_blank\\">D</a>，<a href=\\"https://hacpai.com/article/1597226949061?tdsourcetag=s_pctim_aiomsg\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">原文链接</a></p>","autoDesc":true,"bioChainData":{"outlink":[{"title":"D","link":"07 信息源与贡献者/D.html"}],"backlink":[],"localMap":{"nodes":[{"id":"09 碎记/Markdown实现块级引用双向链接的探索 by D.md","value":{"title":"Markdown实现块级引用双向链接的探索 by D","path":"09 碎记/Markdown实现块级引用双向链接的探索 by D.md","outlink":["07 信息源与贡献者/D.md"],"backlink":[]}},{"id":"07 信息源与贡献者/D.md","value":{"title":"D","path":"07 信息源与贡献者/D.md","outlink":[],"backlink":[]}}],"links":[{"source":"09 碎记/Markdown实现块级引用双向链接的探索 by D.md","target":"07 信息源与贡献者/D.md"}]}}}');export{w as comp,c as data};
